[
  {
    "objectID": "diversity.html#diversity-maximization-with-cardinality-constraints",
    "href": "diversity.html#diversity-maximization-with-cardinality-constraints",
    "title": "Diversity Maximization",
    "section": "Diversity Maximization with cardinality constraints",
    "text": "Diversity Maximization with cardinality constraints\n\nimport libcoral\n\ndiversity = libcoral.DiversityMaximization(\n  10,           # the number of points to select\n  \"remote-edge\" # the diversity type\n)\n\nLet’s build a dummy dataset to try out things:\n\nimport numpy as np\nfrom sklearn.datasets import make_blobs\nfrom matplotlib import pyplot as plt\n\ndata, labels = make_blobs(1000, random_state=123)\ndata = data.astype(np.float32)\nplt.scatter(data[:,0], data[:,1], s=0.5)\n\n\n\n\n\n\n\n\ndiversity_edge = libcoral.DiversityMaximization(4, \"remote-edge\")\nselected_edge = diversity_edge.solve(data)\ncost = diversity_edge.cost(data[selected_edge])\nplt.figure()\nplt.suptitle(\"remote-edge diversity\")\nplt.title(f\"cost (minimum distance): {cost:.2f}\")\nplt.scatter(data[:,0], data[:,1], s=0.5)\n# Plot the selection of points\nplt.scatter(data[selected_edge,0], data[selected_edge,1], s=20, color=\"red\")\n\ndiversity_clique = libcoral.DiversityMaximization(4, \"remote-clique\")\nselected_clique = diversity_clique.solve(data)\ncost = diversity_clique.cost(data[selected_clique])\nplt.figure()\nplt.suptitle(\"remote-clique diversity\")\nplt.title(f\"cost (sum of distances): {cost:.2f}\")\nplt.scatter(data[:,0], data[:,1], s=0.5)\n# Plot the selection of points\nplt.scatter(data[selected_clique,0], data[selected_clique,1], s=20, color=\"red\")\n\n\n\n\n\n\n\n\n\n\n\nCode\nimport time\n\ndef bench(coreset_size=None):\n    if coreset_size is None:\n        diversity = libcoral.DiversityMaximization(10, \"remote-clique\")\n    else:\n        diversity = libcoral.DiversityMaximization(10, \"remote-clique\", coreset_size=coreset_size)\n\n    sizes = list(range(1000, 2000, 100))\n    times = []\n    costs = []\n    for n in sizes:\n        data, labels = make_blobs(n, random_state=123)\n        data = data.astype(np.float32)\n        start = time.time()\n        selected = diversity.solve(data)\n        end = time.time()\n        times.append(end - start)\n        costs.append(diversity.cost(data[selected]))\n    return dict(sizes=sizes, times=times, costs=costs)\n\nresults_baseline = bench(None)\nresults_coreset = bench(500)\n\nplt.figure()\nplt.title(\"Running time\")\nplt.plot(results_baseline[\"sizes\"], results_baseline[\"times\"], label=\"baseline\")\nplt.plot(results_coreset[\"sizes\"], results_coreset[\"times\"], label=\"coreset\")\nplt.legend()\n\nplt.figure()\nplt.title(\"Cost (sum of distances)\")\nplt.scatter(results_baseline[\"sizes\"], results_baseline[\"costs\"], label=\"baseline\")\nplt.scatter(results_coreset[\"sizes\"], results_coreset[\"costs\"], label=\"coreset\")\nplt.legend()",
    "crumbs": [
      "Algorithms"
    ]
  },
  {
    "objectID": "diversity.html#diversity-maximization-with-matroid-constraints",
    "href": "diversity.html#diversity-maximization-with-matroid-constraints",
    "title": "Diversity Maximization",
    "section": "Diversity Maximization with Matroid Constraints",
    "text": "Diversity Maximization with Matroid Constraints\nFor experimenting with matroid constraints we will use the fashion-mnist dataset, which comprises 60000 28x28 images of apparel items out of 10 possible categories.\n\n\n\nImage from the original source (Zalando’s Github)\n\n\n\n\nCode\ndef load_fashion_mnist():\n    \"\"\"This function just downloads the 60k training images of fashion-mnist locally, if not already available,\n    and returns them as a float32 array.\n    \"\"\"\n    import urllib.request\n    import os\n    import gzip\n    import umap\n\n    fashion_local = \"train-images-idx3-ubyte.gz\"\n    fashion_url = \"https://raw.githubusercontent.com/zalandoresearch/fashion-mnist/master/data/fashion/train-images-idx3-ubyte.gz\"\n    fashion_labels_local = \"train-labels-idx1-ubyte.gz\"\n    fashion_labels_url = \"https://github.com/zalandoresearch/fashion-mnist/raw/master/data/fashion/train-labels-idx1-ubyte.gz\"\n    if not os.path.isfile(fashion_local):\n        print(\"downloading fashion-mnist file\")\n        urllib.request.urlretrieve(fashion_url, fashion_local)\n    if not os.path.isfile(fashion_labels_local):\n        print(\"downloading fashion-mnist file\")\n        urllib.request.urlretrieve(fashion_labels_url, fashion_labels_local)\n    with gzip.open(fashion_local, 'rb') as imgpath:\n        images = np.frombuffer(imgpath.read(), dtype=np.uint8,\n                               offset=16).reshape(60000, 784)\n    with gzip.open(fashion_labels_local, 'rb') as lbpath:\n        labels = np.frombuffer(lbpath.read(), dtype=np.uint8,\n                               offset=8)\n\n    data = images.astype(np.float32)\n\n    umap_file = \"fashion-mnist-umap.npy\"\n    if not os.path.isfile(umap_file):\n        embed = umap.UMAP()\n        embedding = embed.fit_transform(data)\n        np.save(umap_file, embedding)\n    embedding = np.load(umap_file)\n\n    return data, labels.astype(np.uint32), embedding\n\n\nWe define a partition matroid on the categories, requiring that at most one item is picked from each category:\n\npartition_matroid = libcoral.MatroidDescription([1] * 10)\n\nThen we instantiate the algorithm so to find a solution that respects the matroid constraint. Note that we use a matroid constraint: in this case it is absolutely required, as the approximation algorithm for Diversity Maximization under matroid constraints is a very expensive local search.\n\ndiversity = libcoral.DiversityMaximization(\n    10, # how many points we want\n    \"remote-clique\", # the type of diversity\n    coreset_size=500, # the size of the coreset\n    matroid=partition_matroid # the matroid constraint\n)\n\nTo actually solve the problem we now need information about labels along with the data. We also get a 2-dimensional embedding for visualization purposes.\n\ndata, categories, embedding = load_fashion_mnist()\nprint(data.shape, categories.shape)\n\n(60000, 784) (60000,)\n\n\n\nplt.figure(figsize=(10,10))\nplt.scatter(\n    embedding[:,0],\n    embedding[:,1],\n    c=categories,\n    cmap=\"tab10\",\n    s=0.01\n)\n\n\n\n\n\n\n\n\nWe will now select 10 points without matroid constraints.\n\ndiversity = libcoral.DiversityMaximization(\n    10,\n    \"remote-clique\",\n    coreset_size=1000\n)\nselected = diversity.solve(embedding)\ncost = diversity.cost(embedding[selected])\n\n\npalette = np.array(plt.get_cmap('tab10').colors)\ncolors = palette[categories]\n\nplt.figure(figsize=(10,10))\nplt.scatter(\n    embedding[:,0],\n    embedding[:,1],\n    c=colors,\n    cmap=\"tab10\",\n    s=0.01\n)\nplt.scatter(\n    embedding[selected,0],\n    embedding[selected,1],\n    c=colors[selected,:],\n    edgecolors=\"black\",\n    cmap=\"tab10\",\n    s=100\n)\n\n/tmp/ipykernel_41860/1306738225.py:5: UserWarning: No data for colormapping provided via 'c'. Parameters 'cmap' will be ignored\n  plt.scatter(\n/tmp/ipykernel_41860/1306738225.py:12: UserWarning: No data for colormapping provided via 'c'. Parameters 'cmap' will be ignored\n  plt.scatter(\n\n\n\n\n\n\n\n\n\nAnd now with Matroid Constraints.\n\ndiversity = libcoral.DiversityMaximization(\n    10,\n    \"remote-clique\",\n    coreset_size=2000,\n    matroid=partition_matroid\n)\nselected = diversity.solve(embedding, categories)\ncost = diversity.cost(embedding[selected])\nprint(categories[selected])\n\n[6 1 8 3 7 5 9 0 4 2]\n\n\n\nplt.figure(figsize=(10,10))\nplt.scatter(\n    embedding[:,0],\n    embedding[:,1],\n    c=colors,\n    cmap=\"tab10\",\n    s=0.01\n)\nplt.scatter(\n    embedding[selected,0],\n    embedding[selected,1],\n    c=colors[selected,:],\n    edgecolors=\"black\",\n    cmap=\"tab10\",\n    s=100\n)\n\n/tmp/ipykernel_41860/3931432447.py:2: UserWarning: No data for colormapping provided via 'c'. Parameters 'cmap' will be ignored\n  plt.scatter(\n/tmp/ipykernel_41860/3931432447.py:9: UserWarning: No data for colormapping provided via 'c'. Parameters 'cmap' will be ignored\n  plt.scatter(",
    "crumbs": [
      "Algorithms"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "libcoral",
    "section": "",
    "text": "This library collects several computational geometry algorithms based on the coreset technique. Currently the focus is on clustering and diversity maximization, under a variety of constraints.\nThe problems this library deals with are NP-hard and often have rather expensive approximation algorithms. To speed up the computation, the library employs coresets. A coreset is a concise summary of the data that retains information about the overall structure: approximation algorithms (even expensive ones!!) can be run on this small summary while still yielding solutions that are valid with respect to the full dataset.\n\nDiversity maximization",
    "crumbs": [
      "Introduction"
    ]
  }
]