[
  {
    "objectID": "diversity.html",
    "href": "diversity.html",
    "title": "Diversity Maximization",
    "section": "",
    "text": "Intuitively, the diversity maximization requires to find a set of diverse elements out of a set of points. The dissimilarity between points is measured by some distance function, for instance the Euclidean distance function.\nMore formally, given a dataset of points in a metric space and an integer \\(k\\), a diversity maximization problem requires determining a subset of \\(k\\) points maximizing some diversity objective measure.\nThere are several possible objective measures, whose names derive from the distances considered in the points of the solution.\n\n\n\nAll these problems are NP-hard, and thus libcoral implements several approximation algorithms.\nlibcoral currently supports the remote-edge and the remote-clique diversity notions, which require to maximize, respectively, the minimum distance between any two points of the solution and the sum of pairwise distances of the points of the solution.",
    "crumbs": [
      "Algorithms"
    ]
  },
  {
    "objectID": "diversity.html#what-is-diversity-maximization",
    "href": "diversity.html#what-is-diversity-maximization",
    "title": "Diversity Maximization",
    "section": "",
    "text": "Intuitively, the diversity maximization requires to find a set of diverse elements out of a set of points. The dissimilarity between points is measured by some distance function, for instance the Euclidean distance function.\nMore formally, given a dataset of points in a metric space and an integer \\(k\\), a diversity maximization problem requires determining a subset of \\(k\\) points maximizing some diversity objective measure.\nThere are several possible objective measures, whose names derive from the distances considered in the points of the solution.\n\n\n\nAll these problems are NP-hard, and thus libcoral implements several approximation algorithms.\nlibcoral currently supports the remote-edge and the remote-clique diversity notions, which require to maximize, respectively, the minimum distance between any two points of the solution and the sum of pairwise distances of the points of the solution.",
    "crumbs": [
      "Algorithms"
    ]
  },
  {
    "objectID": "diversity.html#diversity-maximization-with-cardinality-constraints",
    "href": "diversity.html#diversity-maximization-with-cardinality-constraints",
    "title": "Diversity Maximization",
    "section": "Diversity Maximization with cardinality constraints",
    "text": "Diversity Maximization with cardinality constraints\nThe most straightforward formulation of the diversity maximization problem requires to find a subset of \\(k\\) points of the input.\nIn libcoral, this is achieved by instantiating a DiversityMaximization object, which takes a variety of parameters. In its simplest form, the invocation is the following:\n\nimport libcoral\n\ndiversity = libcoral.DiversityMaximization(\n  10,           # the number of points to select\n  \"remote-edge\" # the diversity type, can also be \"remote-clique\"\n)\n\nThe diversity object then has a solve method that accepts a numpy 2-dimensional array of float32 data, where each row is a data point of the set. The solve method returns an array of integers, which are the integers of the rows of the input corresponding to the solution. There is a cost method as well, that returns the cost of any set of points.\nLet’s build a dummy dataset to try out things:\n\nimport numpy as np\nfrom sklearn.datasets import make_blobs\nfrom matplotlib import pyplot as plt\nimport seaborn as sns\n\ndata, labels = make_blobs(1000, random_state=123)\ndata = data.astype(np.float32)\nplt.scatter(data[:,0], data[:,1], s=0.5)\n\n\n\n\n\n\n\n\nThe following code snippet sets up and solve both remote-edge and remote-clique on the set of points created above.\n# set up and solve the remote-edge problem\ndiversity_edge = libcoral.DiversityMaximization(4, \"remote-edge\")\nselected_edge = diversity_edge.solve(data)\ncost = diversity_edge.cost(data[selected_edge])\n\nplt.figure()\nplt.suptitle(\"remote-edge diversity\")\nplt.title(f\"cost (minimum distance): {cost:.2f}\")\nplt.scatter(data[:,0], data[:,1], s=0.5)\n# Plot the selection of points\nplt.scatter(data[selected_edge,0], data[selected_edge,1], s=20, color=\"red\")\n\n# set up and solve the remote-clique problem\ndiversity_clique = libcoral.DiversityMaximization(4, \"remote-clique\")\nselected_clique = diversity_clique.solve(data)\ncost = diversity_clique.cost(data[selected_clique])\n\nplt.figure()\nplt.suptitle(\"remote-clique diversity\")\nplt.title(f\"cost (sum of distances): {cost:.2f}\")\nplt.scatter(data[:,0], data[:,1], s=0.5)\n# Plot the selection of points\nplt.scatter(data[selected_clique,0], data[selected_clique,1], s=20, color=\"red\")\n\n\n\n\n\n\n\n\n\n\nAs you can see, the two solutions look quite different in terms of position of the points. Oftentimes, the remote-clique solution has points which are grouped in two clusters. This is an effect of the 2-approximation algorithm used to solve it, which is based on finding a maximum-weight matching.\nThe code above, especially for the remote-clique problem, has one problem: for large datasets it tends to be quite slow. This is because the approximation algorithm has a high computational complexity.\nTo address this problem, libcoral implements the coreset-based approach described in (Ceccarello et al. 2017). In order to use the coreset-based approach, the instantiation of the DiversityMaximization object requires the additional parameter coreset size:\n\ndiversity = libcoral.DiversityMaximization(\n    10,\n    \"remote-clique\",\n    coreset_size=1000\n)\n\nHigher values of coreset_size yield more accurate solutions at the expense of the running time. The plots below report the running time (left) and the cost of the solutions (right), comparing the baseline algorithm without coresets (in blue) with the coreset-based algorithm (in orange) using a coreset of size 500.\n\nCode\nimport time\n\ndef bench(coreset_size=None):\n    if coreset_size is None:\n        diversity = libcoral.DiversityMaximization(10, \"remote-clique\")\n    else:\n        diversity = libcoral.DiversityMaximization(10, \"remote-clique\", coreset_size=coreset_size)\n\n    sizes = list(range(1000, 2000, 100))\n    times = []\n    costs = []\n    for n in sizes:\n        data, labels = make_blobs(n, random_state=123)\n        data = data.astype(np.float32)\n        start = time.time()\n        selected = diversity.solve(data)\n        end = time.time()\n        times.append(end - start)\n        costs.append(diversity.cost(data[selected]))\n    return dict(sizes=sizes, times=times, costs=costs)\n\nresults_baseline = bench(None)\nresults_coreset = bench(500)\n\nplt.figure()\nplt.title(\"Running time\")\nplt.xlabel(\"Dataset size\")\nplt.ylabel(\"Running time\")\nplt.plot(results_baseline[\"sizes\"], results_baseline[\"times\"], label=\"baseline\")\nplt.plot(results_coreset[\"sizes\"], results_coreset[\"times\"], label=\"coreset\")\nplt.legend()\n\nplt.figure()\nplt.title(\"Cost (sum of distances)\")\nplt.xlabel(\"Dataset size\")\nplt.ylabel(\"remote-clique cost\")\nplt.scatter(results_baseline[\"sizes\"], results_baseline[\"costs\"], label=\"baseline\")\nplt.scatter(results_coreset[\"sizes\"], results_coreset[\"costs\"], label=\"coreset\")\nplt.legend()\n\n\n\n\n\n\n\n\n\n\n\nClearly, the running time using coresets is a fraction of the baseline. As for the cost, recall that for diversity maximization higher is better: we observe that on larger datasets the coreset introduces a moderate loss of quality.",
    "crumbs": [
      "Algorithms"
    ]
  },
  {
    "objectID": "diversity.html#diversity-maximization-with-matroid-constraints",
    "href": "diversity.html#diversity-maximization-with-matroid-constraints",
    "title": "Diversity Maximization",
    "section": "Diversity Maximization with Matroid Constraints",
    "text": "Diversity Maximization with Matroid Constraints\nAn important variant of the diversity maximization primitive prescribes that the solution satisfies an additional orthogonal requirement, which can be specified as a matroid constraint (i.e., a feasible solution must be an independent set of size \\(k\\)).\nFor instance, if we have a labelled dataset and we want the solution to contain at most \\(k_\\ell\\) points with label \\(\\ell\\), we can set up a diversity maximization problem with a partition matroid constraint.\nFor experimenting with matroid constraints we will use the fashion-mnist dataset, which comprises 60000 28x28 images of apparel items out of 10 possible categories. Each image then corresponds to a 784 dimensional vector.\n\n\n\nImage from the original source (Zalando’s Github)\n\n\nFor the sake of example, we embed the dataset in two dimensions using UMAP.\n\n\nCode\ndef load_fashion_mnist(seed=None, sample_size=None):\n    \"\"\"This function just downloads the 60k training images of fashion-mnist locally, if not already available,\n    and returns them as a float32 array.\n    \"\"\"\n    import urllib.request\n    import os\n    import gzip\n    import umap\n    import numpy as np\n\n    fashion_local = \"train-images-idx3-ubyte.gz\"\n    fashion_url = \"https://raw.githubusercontent.com/zalandoresearch/fashion-mnist/master/data/fashion/train-images-idx3-ubyte.gz\"\n    fashion_labels_local = \"train-labels-idx1-ubyte.gz\"\n    fashion_labels_url = \"https://github.com/zalandoresearch/fashion-mnist/raw/master/data/fashion/train-labels-idx1-ubyte.gz\"\n    if not os.path.isfile(fashion_local):\n        print(\"downloading fashion-mnist file\")\n        urllib.request.urlretrieve(fashion_url, fashion_local)\n    if not os.path.isfile(fashion_labels_local):\n        print(\"downloading fashion-mnist file\")\n        urllib.request.urlretrieve(fashion_labels_url, fashion_labels_local)\n    with gzip.open(fashion_local, 'rb') as imgpath:\n        images = np.frombuffer(imgpath.read(), dtype=np.uint8,\n                               offset=16).reshape(60000, 784)\n    with gzip.open(fashion_labels_local, 'rb') as lbpath:\n        labels = np.frombuffer(lbpath.read(), dtype=np.uint8,\n                               offset=8)\n\n    data = images.astype(np.float32)\n\n    umap_file = \"fashion-mnist-umap.npy\"\n    if not os.path.isfile(umap_file):\n        embed = umap.UMAP()\n        embedding = embed.fit_transform(data)\n        np.save(umap_file, embedding)\n    embedding = np.load(umap_file)\n\n    if sample_size is not None:\n        print(\"returning sampled\")\n        seed = seed if seed is not None else 1234\n        gen = np.random.default_rng()\n        idxs = np.arange(data.shape[0])\n        gen.shuffle(idxs)\n        idxs = idxs[:sample_size]\n        return data[idxs], labels.astype(np.uint32)[idxs], embedding[idxs]\n    if seed is not None:\n        gen = np.random.default_rng()\n        idxs = np.arange(data.shape[0])\n        gen.shuffle(idxs)\n        return data[idxs], labels.astype(np.uint32)[idxs], embedding[idxs]\n        \n    return data, labels.astype(np.uint32), embedding\n\n\nWe define a partition matroid on the categories, requiring that at most one item is picked from each category:\n\npartition_matroid = libcoral.MatroidDescription([1] * 10)\n\nThen we instantiate the algorithm so to find a solution that respects the matroid constraint. Note that we provide the coreset_size parameter: this case it is absolutely required, as the approximation algorithm for Diversity Maximization under matroid constraints is a very expensive local search. The algorithms used in this case are described in (Ceccarello, Pietracaprina, and Pucci 2018) and (Ceccarello, Pietracaprina, and Pucci 2020).\n\ndiversity = libcoral.DiversityMaximization(\n    10, # how many points we want\n    \"remote-clique\", # the type of diversity\n    coreset_size=1000, # the size of the coreset\n    matroid=partition_matroid # the matroid constraint\n)\n\nTo actually solve the problem we now need information about labels along with the data.\n\ndata, categories, embedding = load_fashion_mnist(seed=1234)\n\n\n\nCode\npalette = [\n  \"#5778a4\",\n  \"#e49444\",\n  \"#d1615d\",\n  \"#85b6b2\",\n  \"#6a9f58\",\n  \"#e7ca60\",\n  \"#a87c9f\",\n  \"#f1a2a9\",\n  \"#967662\",\n  \"#b8b0ac\",\n]\nplt.figure(figsize=(8,8))\nsns.scatterplot(\n    x=embedding[:,0],\n    y=embedding[:,1],\n    hue=categories,\n    palette=palette,\n    s=1,\n    edgecolors=None,\n    legend=False\n)\n\n\n\n\n\n\n\n\n\nWe will now select 10 points without matroid constraints.\n\ndiversity = libcoral.DiversityMaximization(\n    10,\n    \"remote-clique\",\n    coreset_size=5000\n)\nselected = diversity.solve(embedding)\ncost = diversity.cost(embedding[selected])\n\nNotice that we have more than one point per category. Also note that some of the selected points appear to be outside of their color’s cluster: this is due to the fact that some points are actually far away from other points from the same category.\n\n\nCode\nplt.figure(figsize=(8,8))\n\nax = plt.gca()\ncost = diversity.cost(embedding[selected])\nax.set_title(f\"remote-clique cost: {cost:.2f}\")\nsns.scatterplot(\n    x=embedding[:,0],\n    y=embedding[:,1],\n    hue=categories,\n    palette=palette,\n    s=1,\n    edgecolors=None,\n    legend=False,\n    ax=ax\n)\nsns.scatterplot(\n    x=embedding[selected,0],\n    y=embedding[selected,1],\n    hue=categories[selected],\n    palette=palette,\n    s=100,\n    edgecolors=\"black\",\n    legend=False,\n    ax=ax\n)\n\n\n/tmp/ipykernel_20342/2573716032.py:16: UserWarning: The palette list has more values (10) than needed (3), which may not be intended.\n  sns.scatterplot(\n\n\n\n\n\n\n\n\n\nSolving the problem with matroid constraints returns a point from each category, as required by the partition matroid constraint.\n\ndiversity = libcoral.DiversityMaximization(\n    10,\n    \"remote-clique\",\n    coreset_size=5000,\n    matroid=partition_matroid\n)\nselected = diversity.solve(embedding, categories)\ncost = diversity.cost(embedding[selected])\nprint(categories[selected])\n\n[9 6 7 1 3 0 8 4 2 5]\n\n\n\n\nCode\nplt.figure(figsize=(8,8))\nax = plt.gca()\ncost = diversity.cost(embedding[selected])\nax.set_title(f\"remote-clique cost: {cost:.2f}\")\nsns.scatterplot(\n    x=embedding[:,0],\n    y=embedding[:,1],\n    hue=categories,\n    palette=palette,\n    s=1,\n    edgecolors=None,\n    legend=False,\n    ax=ax\n)\nsns.scatterplot(\n    x=embedding[selected,0],\n    y=embedding[selected,1],\n    hue=categories[selected],\n    palette=palette,\n    s=100,\n    edgecolors=\"black\",\n    legend=False,\n    ax=ax\n)",
    "crumbs": [
      "Algorithms"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "libcoral",
    "section": "",
    "text": "This library collects several computational geometry algorithms based on the coreset technique. Currently the focus is on clustering and diversity maximization, under a variety of constraints.\nThe problems this library deals with are NP-hard and often have rather expensive approximation algorithms. To speed up the computation, the library employs coresets. A coreset is a concise summary of the data that retains information about the overall structure: approximation algorithms (even expensive ones!!) can be run on this small summary while still yielding solutions that are valid with respect to the full dataset.\nThe package currently supports the following algorithms:\n\nDiversity maximization\n\nThe software is implemented in Rust with a Python interface. It can be used from R as well.",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "using-with-r.html",
    "href": "using-with-r.html",
    "title": "Using with R",
    "section": "",
    "text": "libcoral is released as a Python library, but it is rather easy to use from R as well, thanks to the reticulate package.\nConsider the following small example dataset, which comprises 100 2-dimensional points.\n\nset.seed(1234)\ndat &lt;- matrix(rnorm(200), 100, 2)\n\nThe following snippet shows how to import the libcoral Python package using reticulate, how to instantiate a Diversity Maximization solver and how to pass the dataset.\n\nlibrary(reticulate)\n\nlibcoral &lt;- import(\"libcoral\")\n\ndiversity &lt;- libcoral$DiversityMaximization(4L, \"remote-edge\")\nselector &lt;- diversity$solve(\n1  np_array(dat, \"float32\")\n)\n# we have to offset it by 1!\n2selector &lt;- selector + 1\n\n\n1\n\nNote that we have to use the reticulate::np_array function to convert from a R matrix to a numpy 2-dimensional array. It is especially important that the data type is float32, as that is the only float representation currently supported by libcoral.\n\n2\n\nPython and R have different indexing conventions. Hence the indices returned by diversity$solve are 0-based, whereas R expects 1-based indices.\n\n\n\n\nThe result of the diversity maximization problem can then be plotted as follows.\n\nlibrary(ggplot2)\ndf &lt;- as.data.frame(dat)\nsolution &lt;- as.data.frame(dat[selector,])\nggplot(df, aes(V1, V2)) +\n  geom_point() +\n  geom_point(data=solution, color=\"#CB4154\", size=5)",
    "crumbs": [
      "Using with R"
    ]
  }
]